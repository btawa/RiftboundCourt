<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Riftbound Tournament Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json" />
  
  <!-- Mobile app behavior -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Riftbound" />
  <meta name="theme-color" content="#2563eb" />
  
  <!-- Prevent zoom on input focus -->
  <meta name="format-detection" content="telephone=no" />
  
  <!-- App icons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <style>
    :root {
      --bg: #f6f7fb;
      --card: #ffffff;
      --accent: #2563eb;
      --accent-soft: #e0edff;
      --muted: #6b7280;
      --text: #111827;
      --radius-lg: 18px;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 45px rgba(15,23,42,0.12);
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "SF Pro Text", "Segoe UI", sans-serif;
      color: var(--text);
      background: var(--bg);
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    .app-shell {
      max-width: 480px;
      margin: 0 auto;
      padding: 12px 12px 32px;
    }

    /* Auth view */
    #authView {
      max-width: 480px;
      margin: 40px auto;
      padding: 0 12px;
    }

    .auth-card {
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 18px 18px 20px;
      box-shadow: var(--shadow-soft);
    }

    .auth-title {
      font-weight: 700;
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .auth-subtitle {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 12px;
    }

    .auth-toggle {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 8px;
      text-align: center;
    }

    .auth-toggle button {
      border: none;
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      font-size: 0.8rem;
      padding: 0;
    }

    .auth-error {
      font-size: 0.8rem;
      color: #b91c1c;
      margin-bottom: 8px;
      display: none;
    }

    /* Header card */
    .event-header-card {
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 16px 18px 14px;
      box-shadow: var(--shadow-soft);
      margin-bottom: 12px;
    }

    .event-header-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .event-header-main {
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex: 1;
      min-width: 0;
    }

    .event-title {
      font-weight: 700;
      font-size: 1.1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .event-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .record-pill {
      font-weight: 700;
      font-size: 1rem;
      color: #111827;
      white-space: nowrap;
    }

    .back-button {
      border: none;
      background: transparent;
      padding: 4px 6px 4px 0;
      font-size: 0.85rem;
      color: var(--accent);
      cursor: pointer;
    }

    .icon-button {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 4px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* User info / logout */
    .user-pill {
      font-size: 0.75rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .user-pill button {
      border: none;
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      font-size: 0.75rem;
      padding: 0;
    }

    /* Generic add row */
    .add-row {
      padding: 10px 18px 12px;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;
      text-align: center;
      cursor: pointer;
      font-size: 1rem;
      border-radius: 0 0 var(--radius-lg) var(--radius-lg);
      margin: 0;
    }

    /* Events list */
    .events-card {
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 10px 0 4px;
      box-shadow: var(--shadow-soft);
    }

    .events-header-row {
      display: grid;
      grid-template-columns: 1fr 80px;
      padding: 0 18px 6px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .event-row {
      display: grid;
      grid-template-columns: 1fr 80px;
      padding: 10px 18px;
      border-top: 1px solid #e5e7eb;
      cursor: pointer;
    }

    .event-row:hover {
      background: #f3f4ff;
    }

    .event-name {
      font-weight: 500;
      font-size: 0.9rem;
    }

    .event-deck {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .event-record-wrap {
      text-align: right;
      font-size: 0.8rem;
    }

    .event-record {
      font-weight: 600;
    }

    .event-delete {
      font-size: 0.7rem;
      color: #9ca3af;
      cursor: pointer;
      margin-top: 3px;
      display: inline;
    }

    /* Rounds list for an event */
    .rounds-card {
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 10px 0 4px;
      box-shadow: var(--shadow-soft);
      margin-top: 12px;
      margin-bottom: 16px;
    }

    .rounds-header-row {
      display: grid;
      grid-template-columns: 60px 1fr 80px;
      padding: 0 18px 6px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .round-row {
      display: grid;
      grid-template-columns: 60px 1fr 80px;
      padding: 10px 18px;
      border-top: 1px solid #e5e7eb;
      cursor: pointer;
    }

    .row-win  { background: #dcfce7; }
    .row-loss { background: #fee2e2; }
    .row-draw { background: #e5e7eb; }

    .round-roundnum {
      font-weight: 600;
      color: #9f1239;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .round-roundnum .die {
      font-size: 0.9rem;
    }

    .round-deck-main {
      font-weight: 500;
    }

    .round-actions {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-top: 3px;
    }

    .round-edit-btn,
    .round-delete-btn {
      cursor: pointer;
      display: inline;
    }

    .round-edit-btn {
      margin-right: 6px;
    }

    .round-result {
      text-align: right;
    }

    .result-main-letter {
      font-weight: 700;
      font-size: 0.95rem;
    }

    .result-pattern {
      font-size: 0.75rem;
      color: var(--muted);
    }

    /* Sheets / cards */
    .sheet {
      margin-top: 16px;
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 16px 18px 18px;
      box-shadow: var(--shadow-soft);
      display: none;
    }

    .sheet.visible { display: block; }

    .sheet-title {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 6px;
    }

    .field {
      margin-bottom: 12px;
    }

    .field-label {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    input[type="text"],
    input[type="number"],
    input[type="password"],
    textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      font-size: 0.9rem;
      box-sizing: border-box;
    }

    textarea {
      min-height: 70px;
      resize: vertical;
    }

    /* notes card that always sits between header and rounds */
    .notes-card {
      background: var(--card);
      border-radius: var(--radius-lg);
      padding: 12px 18px 14px;
      box-shadow: var(--shadow-soft);
      margin-bottom: 12px;
      min-height: 110px;
    }

    .notes-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .notes-hint {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .notes-text {
      font-size: 0.85rem;
      color: #374151;
      white-space: pre-wrap;
      margin-top: 4px;
    }

    .notes-text.empty {
      color: var(--muted);
      font-style: italic;
    }

    /* games grid */
    .games-grid {
      display: flex;
      gap: 12px;
      justify-content: flex-start;
    }

    .game-col {
      flex: 0 0 auto;
      min-width: 0;
      text-align: left;
    }

    .game-title {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .chip-group {
      display: flex;
      justify-content: flex-start;
      gap: 6px;
      margin-bottom: 4px;
    }

    .chip-group.small .chip {
      font-size: 0.75rem;
      padding: 4px 8px;
    }

    .chip {
      border-radius: var(--radius-pill);
      padding: 5px 10px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      font-size: 0.8rem;
      cursor: pointer;
      user-select: none;
    }

    .chip.selected {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
      font-weight: 600;
    }

    .small-muted {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: #374151;
    }

    .sheet-footer {
      display: flex;
      gap: 10px;
      margin-top: 16px;
    }

    .btn {
      flex: 1;
      padding: 10px;
      border-radius: var(--radius-pill);
      border: none;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-primary { background: var(--accent); color: #fff; }
    .btn-secondary { background: #f3f4f6; color: #374151; }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 0.9rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 10000;
      pointer-events: none;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Overlay for modals */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 50;
    }

    .overlay.visible {
      display: flex;
    }

    .modal-sheet {
      margin-top: 0;
      max-width: 480px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    /* Stats grid */
    .stats-grid-container {
      overflow-x: auto;
      margin-top: 12px;
      border-radius: var(--radius-lg);
      background: var(--card);
      box-shadow: var(--shadow-soft);
    }

    .stats-grid {
      display: grid;
      min-width: 100%;
      border-collapse: collapse;
    }

    .stats-cell {
      padding: 12px;
      border: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.85rem;
      min-width: 80px;
    }

    .stats-header {
      background: var(--accent-soft);
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .stats-row-header {
      background: var(--accent-soft);
      font-weight: 600;
      position: sticky;
      left: 0;
      z-index: 5;
    }

    .stats-data-cell {
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .stats-data-cell:hover {
      box-shadow: 0 0 0 2px var(--accent);
      z-index: 15;
    }

    .stats-empty {
      background: #f9fafb;
      color: var(--muted);
    }

    .stats-info {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 8px;
      text-align: center;
    }

    .stats-legend {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin: 12px 0;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-box {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    /* Mobile stats view */
    .stats-mobile-view {
      display: none;
    }

    .stats-deck-selector {
      margin: 12px 0;
    }

    .stats-deck-selector select {
      width: 100%;
      padding: 10px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 0.9rem;
      background: var(--card);
    }

    .stats-matchup-card {
      background: var(--card);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-left: 4px solid;
    }

    .stats-matchup-header {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 6px;
    }

    .stats-matchup-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .stats-matchup-winrate {
      font-size: 1.1rem;
      font-weight: 700;
    }

    .stats-view-toggle {
      text-align: center;
      margin-top: 12px;
      font-size: 0.8rem;
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
    }

    /* Responsive layout */
    @media (max-width: 640px) {
      .stats-grid-container {
        display: none;
      }

      .stats-mobile-view {
        display: block;
      }

      .stats-legend {
        flex-wrap: wrap;
      }

      .stats-info::before {
        content: "Select a deck to view matchups. Sorted by win rate (best to worst).";
      }

      .stats-info {
        font-size: 0;
      }

      /* Stack date filter vertically on mobile */
      #statsSheet .stats-date-filter {
        flex-direction: column;
        gap: 8px;
      }

      #statsSheet .stats-date-filter > div {
        width: 100%;
      }

      #statsSheet .stats-date-filter input {
        width: 100%;
        box-sizing: border-box;
      }

      #statsSheet .stats-date-filter button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <!-- AUTH VIEW -->
  <div id="authView">
    <div class="auth-card">
      <div class="auth-title" id="authTitle">Sign in</div>
      <div class="auth-subtitle" id="authSubtitle">
        Log in to your Riftbound tracker or create a new account.
      </div>

      <div id="authError" class="auth-error"></div>

      <form id="authForm">
        <div class="field">
          <div class="field-label">Username</div>
          <input type="text" id="authUsername" autocomplete="username" />
        </div>
        <div class="field">
          <div class="field-label">Password</div>
          <input type="password" id="authPassword" autocomplete="current-password" />
        </div>
        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="authCancelBtn">Clear</button>
          <button type="submit" class="btn btn-primary" id="authSubmitBtn">Log in</button>
        </div>
      </form>

      <div class="auth-toggle">
        <span id="authToggleText">Need an account?</span>
        <button type="button" id="authToggleBtn">Register</button>
      </div>

      <div class="auth-toggle" style="margin-top: 4px;">
        <button type="button" id="forgotPasswordBtn" style="text-decoration: underline;">Forgot password?</button>
      </div>
    </div>
  </div>

  <!-- Password Reset Request Overlay -->
  <div class="overlay" id="resetRequestOverlay">
    <section class="sheet modal-sheet auth-card" style="margin: 0;">
      <div class="sheet-title">Request Password Reset</div>
      <div class="auth-subtitle">Enter your username to generate a reset token.</div>

      <div id="resetRequestError" class="auth-error"></div>

      <form id="resetRequestForm">
        <div class="field">
          <div class="field-label">Username</div>
          <input type="text" id="resetUsername" autocomplete="username" />
        </div>
        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="cancelResetRequestBtn">Cancel</button>
          <button type="submit" class="btn btn-primary">Generate Token</button>
        </div>
      </form>
    </section>
  </div>

  <!-- Password Reset Token Display Overlay -->
  <div class="overlay" id="resetTokenOverlay">
    <section class="sheet modal-sheet auth-card" style="margin: 0;">
      <div class="sheet-title">Reset Token Generated</div>
      <div class="auth-subtitle">Share this token with an admin to verify your identity.</div>

      <div class="field">
        <div class="field-label">Your Reset Token (expires in 24 hours)</div>
        <input type="text" id="displayToken" readonly style="background: #fff; font-family: monospace; font-size: 0.85rem;" />
      </div>

      <div style="font-size: 0.8rem; color: var(--muted); margin-bottom: 12px;">
        Copy this token and contact an admin. Once verified, click "Reset Password" below to use the token.
      </div>

      <div class="sheet-footer">
        <button type="button" class="btn btn-secondary" id="closeTokenBtn">Close</button>
        <button type="button" class="btn btn-primary" id="useTokenBtn">Reset Password</button>
      </div>
    </section>
  </div>

  <!-- Password Reset Confirm Overlay -->
  <div class="overlay" id="resetConfirmOverlay">
    <section class="sheet modal-sheet auth-card" style="margin: 0;">
      <div class="sheet-title">Reset Password</div>
      <div class="auth-subtitle">Enter your token and new password.</div>

      <div id="resetConfirmError" class="auth-error"></div>

      <form id="resetConfirmForm">
        <div class="field">
          <div class="field-label">Reset Token</div>
          <input type="text" id="resetToken" style="font-family: monospace; font-size: 0.85rem;" />
        </div>
        <div class="field">
          <div class="field-label">New Password</div>
          <input type="password" id="resetNewPassword" autocomplete="new-password" />
        </div>
        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="cancelResetConfirmBtn">Cancel</button>
          <button type="submit" class="btn btn-primary">Reset Password</button>
        </div>
      </form>
    </section>
  </div>

  <!-- APP VIEW -->
  <div id="appShell" class="app-shell" style="display:none;">

    <!-- ========== EVENTS LIST VIEW ========== -->
    <div id="eventsView">
      <section class="event-header-card">
        <div class="event-header-row">
          <div class="event-header-main">
            <div class="event-title">Riftbound Events</div>
            <div class="event-subtitle">
              <span id="currentUserLabel"></span>
            </div>
          </div>
          <div class="user-pill">
            <span id="userPillName"></span>
            <button type="button" id="statsBtn">Stats</button>
            <button type="button" id="adminBtn">Admin</button>
            <button type="button" id="logoutBtn">Logout</button>
          </div>
        </div>
      </section>

      <section class="events-card">
        <div class="events-header-row">
          <span>Event</span>
          <span style="text-align:right;">Record</span>
        </div>
        <div id="eventsBody"></div>
        <div class="add-row" id="addEventTrigger">Ôºã Add event</div>
      </section>

      <!-- Add Event Sheet (inline) -->
      <section class="sheet" id="eventSheet">
        <div class="sheet-title">New Event</div>
        <form id="eventForm">
          <div class="field">
            <div class="field-label">Event name</div>
            <input type="text" id="eventName" placeholder="e.g. Regional Houston" />
          </div>
          <div class="field">
            <div class="field-label">Your deck</div>
            <input type="text" id="eventDeck" placeholder="e.g. Miss Fortune" />
          </div>
          <div class="field">
            <div class="field-label">Event date (optional)</div>
            <input type="date" id="eventDate" />
          </div>
          <div class="field">
            <div class="field-label">Link (optional)</div>
            <input type="text" id="eventUrl" placeholder="e.g. decklist URL" />
          </div>
          <div class="sheet-footer">
            <button type="button" class="btn btn-secondary" id="cancelEventBtn">Cancel</button>
            <button type="submit" class="btn btn-primary" id="submitEventBtn">Add event</button>
          </div>
        </form>
      </section>
    </div>

    <!-- ========== EVENT DETAIL VIEW (ROUNDS + NOTES) ========== -->
    <div id="eventDetailView" style="display:none;">
      <section class="event-header-card">
        <div class="event-header-row">
          <button class="back-button" id="backToEventsBtn">‚Üê Events</button>
          <div class="event-header-main">
            <div class="event-title" id="detailEventName">Event</div>
            <div class="event-subtitle">
              <span id="detailEventDeck"></span>
            </div>
          </div>
          <button class="icon-button" id="showEventNotesBtn" title="Toggle edit notes">üìù</button>
          <button class="icon-button" id="editEventBtn" title="Edit event">‚úèÔ∏è</button>
          <div class="record-pill" id="detailRecordDisplay">0-0</div>
        </div>
      </section>

      <!-- Always-visible event notes card -->
      <section class="notes-card" id="eventNotesCard">
        <div class="notes-header">
          <div class="sheet-title">Event notes</div>
          <div class="notes-hint">Tap üìù to edit</div>
        </div>

        <!-- View mode -->
        <div id="eventNotesView">
          <div id="eventCommentsText" class="notes-text empty">
            No event notes yet. Tap üìù to add.
          </div>
        </div>
      </section>

      <section class="rounds-card">
        <div class="rounds-header-row">
          <span>Round</span>
          <span>Deck</span>
          <span style="text-align:right;">Result</span>
        </div>
        <div id="roundsBody"></div>
        <div style="display: flex; gap: 0;">
          <div class="add-row" id="addRoundTrigger" style="flex: 1; border-radius: 0 0 0 var(--radius-lg); border-right: 1px solid #e5e7eb;">Ôºã Add round</div>
          <div class="add-row" id="exportRoundsBtn" style="flex: 1; border-radius: 0 0 var(--radius-lg) 0;">üìã Export to text</div>
        </div>
      </section>
    </div>
  </div>

  <!-- Event Edit Overlay -->
  <div class="overlay" id="eventOverlay">
    <section class="sheet modal-sheet" id="eventEditSheet">
      <div class="sheet-title">Edit Event</div>
      <form id="eventEditForm">
        <div class="field">
          <div class="field-label">Event name</div>
          <input type="text" id="eventEditName" />
        </div>
        <div class="field">
          <div class="field-label">Your deck</div>
          <input type="text" id="eventEditDeck" />
        </div>
        <div class="field">
          <div class="field-label">Event date (optional)</div>
          <input type="date" id="eventEditDate" />
        </div>
        <div class="field">
          <div class="field-label">Link (optional)</div>
          <input type="text" id="eventEditUrl" />
        </div>
        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="cancelEventEditBtn">Cancel</button>
          <button type="submit" class="btn btn-primary" id="saveEventEditBtn">Save changes</button>
        </div>
      </form>
    </section>
  </div>

  <!-- Round Add/Edit Overlay -->
  <div class="overlay" id="roundOverlay">
    <section class="sheet modal-sheet" id="roundSheet">
      <div class="sheet-title" id="roundSheetTitle">Round 1</div>
      <form id="roundForm">
        <div class="field">
          <div class="field-label">Round</div>
          <input type="number" id="roundNumber" min="1" value="1" />
        </div>

        <div class="field">
          <div class="field-label">Opponent's deck</div>
          <input type="text" id="oppDeck" placeholder="e.g. Fire Aggro" />
        </div>

        <div class="field">
          <div class="field-label">Round 1 die roll</div>
          <div class="checkbox-row">
            <span class="small-muted">Check if you won the die roll for this round.</span>
            <label class="checkbox-label">
              <input type="checkbox" id="dieRollWon" />
              <span>Won die roll</span>
            </label>
          </div>
        </div>

        <div class="field">
          <div class="field-label">Games</div>
          <div class="games-grid">
            <!-- Game 1 -->
            <div class="game-col" id="game1Col">
              <div class="game-title">Game 1</div>
              <div class="chip-group" data-chip-group="g1Result">
                <div class="chip" data-value="W">W</div>
                <div class="chip" data-value="L">L</div>
                <div class="chip" data-value="T">T</div>
              </div>
              <div class="chip-group small" data-chip-group="g1Play">
                <div class="chip" data-value="1st">1st</div>
                <div class="chip" data-value="2nd">2nd</div>
              </div>
            </div>

            <!-- Game 2 -->
            <div class="game-col" id="game2Col" style="display:none;">
              <div class="game-title">Game 2</div>
              <div class="chip-group" data-chip-group="g2Result">
                <div class="chip" data-value="W">W</div>
                <div class="chip" data-value="L">L</div>
                <div class="chip" data-value="T">T</div>
              </div>
              <div class="chip-group small" data-chip-group="g2Play">
                <div class="chip" data-value="1st">1st</div>
                <div class="chip" data-value="2nd">2nd</div>
              </div>
            </div>

            <!-- Game 3 -->
            <div class="game-col" id="game3Col" style="display:none;">
              <div class="game-title">Game 3</div>
              <div class="chip-group" data-chip-group="g3Result">
                <div class="chip" data-value="W">W</div>
                <div class="chip" data-value="L">L</div>
                <div class="chip" data-value="T">T</div>
              </div>
              <div class="chip-group small" data-chip-group="g3Play">
                <div class="chip" data-value="1st">1st</div>
                <div class="chip" data-value="2nd">2nd</div>
              </div>
            </div>
          </div>
        </div>

        <div class="small-muted" id="matchSummary">
          Set Game 1 to begin. Leaving Game 2/3 empty = Best of 1.
        </div>

        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="cancelRoundBtn">Cancel</button>
          <button type="submit" class="btn btn-primary" id="saveRoundBtn">Add round</button>
        </div>
      </form>
    </section>
  </div>

  <!-- Round Detail Overlay -->
  <div class="overlay" id="roundDetailOverlay">
    <section class="sheet modal-sheet" id="roundDetailSheet">
      <div class="sheet-title" id="roundDetailTitle">Round details</div>

      <div class="field">
        <div class="field-label">Opponent's deck</div>
        <div id="roundDetailOppDeck"></div>
      </div>

      <div class="field">
        <div class="field-label">Die roll</div>
        <div id="roundDetailDieRoll"></div>
      </div>

      <div class="field">
        <div class="field-label">Games</div>
        <div id="roundDetailGames"></div>
      </div>

      <div class="field">
        <div class="field-label">Comments</div>
        <textarea id="roundDetailComments" placeholder="Notes about this match, sequencing, misplays, sideboard plans..."></textarea>
      </div>

      <div class="sheet-footer">
        <button type="button" class="btn btn-secondary" id="closeRoundDetailBtn">Close</button>
        <button type="button" class="btn btn-primary" id="saveRoundCommentsBtn">Save notes</button>
      </div>
    </section>
  </div>

  <!-- Event Notes Overlay -->
  <div class="overlay" id="eventNotesOverlay">
    <section class="sheet modal-sheet" id="eventNotesSheet">
      <div class="sheet-title">Edit Event Notes</div>
      <form id="eventNotesForm">
        <div class="field">
          <div class="field-label">Comments</div>
          <textarea id="eventCommentsInput" placeholder="Overall notes about the event, meta, misplays, etc."></textarea>
        </div>
        <div class="sheet-footer">
          <button type="button" class="btn btn-secondary" id="cancelEventCommentsBtn">Cancel</button>
          <button type="submit" class="btn btn-primary" id="saveEventCommentsBtn">Save notes</button>
        </div>
      </form>
    </section>
  </div>

  <!-- Admin Panel Overlay -->
  <div class="overlay" id="adminOverlay">
    <section class="sheet modal-sheet" id="adminSheet">
      <div class="sheet-title">Admin Panel</div>

      <!-- Tab buttons -->
      <div style="display: flex; gap: 8px; margin: 12px 0; border-bottom: 1px solid #e5e7eb;">
        <button type="button" id="adminTabResets" class="admin-tab active" style="flex: 1; padding: 8px; border: none; background: transparent; cursor: pointer; border-bottom: 2px solid var(--accent); font-weight: 600;">Password Resets</button>
        <button type="button" id="adminTabUsers" class="admin-tab" style="flex: 1; padding: 8px; border: none; background: transparent; cursor: pointer; border-bottom: 2px solid transparent;">User Management</button>
      </div>

      <!-- Password Reset Requests Tab -->
      <div id="adminResetsContent" class="admin-tab-content">
        <div id="adminPendingRequests" style="margin-top: 12px;">
          <!-- Pending requests will be inserted here -->
        </div>
      </div>

      <!-- User Management Tab -->
      <div id="adminUsersContent" class="admin-tab-content" style="display: none;">
        <div id="adminUsersList" style="margin-top: 12px;">
          <!-- Users list will be inserted here -->
        </div>
      </div>

      <div class="sheet-footer">
        <button type="button" class="btn btn-secondary" id="closeAdminBtn">Close</button>
      </div>
    </section>
  </div>

  <!-- Stats Overlay -->
  <div class="overlay" id="statsOverlay">
    <section class="sheet modal-sheet" id="statsSheet" style="max-width: 800px;">
      <div class="sheet-title">Matchup Win Rates</div>

      <div style="display: flex; gap: 8px; margin: 12px 0; border-bottom: 1px solid #e5e7eb; justify-content: center;">
        <button type="button" id="statsTabMatches" class="stats-tab" style="flex: 0 0 auto; padding: 8px 16px; border: none; background: transparent; cursor: pointer; border-bottom: 2px solid var(--accent); font-weight: 600;">Match Win %</button>
        <button type="button" id="statsTabGames" class="stats-tab" style="flex: 0 0 auto; padding: 8px 16px; border: none; background: transparent; cursor: pointer; border-bottom: 2px solid transparent;">Game Win %</button>
      </div>

      <div class="stats-date-filter" style="display: flex; gap: 12px; align-items: center; justify-content: center; margin: 12px 0; padding: 12px; background: var(--accent-soft); border-radius: 8px;">
        <div style="display: flex; align-items: center; gap: 6px;">
          <label for="statsStartDate" style="font-size: 0.85rem; font-weight: 500;">From:</label>
          <input type="date" id="statsStartDate" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.85rem;" />
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <label for="statsEndDate" style="font-size: 0.85rem; font-weight: 500;">To:</label>
          <input type="date" id="statsEndDate" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.85rem;" />
        </div>
        <button type="button" id="statsApplyDateRange" class="btn btn-primary" style="padding: 6px 12px; font-size: 0.85rem;">Apply</button>
        <button type="button" id="statsClearDateRange" class="btn btn-secondary" style="padding: 6px 12px; font-size: 0.85rem;">Clear</button>
      </div>

      <div class="stats-legend">
        <div class="legend-item">
          <div class="legend-box" style="background: #991b1b;"></div>
          <span>0% WR</span>
        </div>
        <div class="legend-item">
          <div class="legend-box" style="background: #fef08a;"></div>
          <span>50% WR</span>
        </div>
        <div class="legend-item">
          <div class="legend-box" style="background: #166534;"></div>
          <span>100% WR</span>
        </div>
      </div>

      <div class="stats-grid-container">
        <div id="statsGridContent">
          <!-- Grid will be inserted here -->
        </div>
      </div>

      <div class="stats-mobile-view">
        <div class="stats-deck-selector">
          <label for="statsMobileDeckSelect" style="font-size: 0.85rem; font-weight: 500; display: block; margin-bottom: 6px;">Select your deck:</label>
          <select id="statsMobileDeckSelect">
            <option value="">-- Select a deck --</option>
          </select>
        </div>
        <div id="statsMobileContent">
          <!-- Mobile cards will be inserted here -->
        </div>
      </div>

      <div class="stats-info" id="statsInfoText">
        Hover over colored cells to see detailed record (wins-losses-draws). Rows = your deck, Columns = opponent's deck.
      </div>

      <div class="sheet-footer">
        <button type="button" class="btn btn-secondary" id="closeStatsBtn">Close</button>
      </div>
    </section>
  </div>

  <!-- Toast notification -->
  <div class="toast" id="toast"></div>

  <script>
    let currentEvent = null;
    let currentRounds = [];
    let currentDetailRound = null;
    let editingRoundId = null;
    let currentUser = null;
    let authMode = "login"; // "login" | "register"
    let statsMode = "matches"; // "matches" | "games"
    let currentStatsData = null; // Store current stats for mobile view

    /* ---- Toast notification ---- */

    function showToast(message) {
      const toast = document.getElementById("toast");
      toast.textContent = message;
      toast.classList.add("show");

      setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }

    /* ---- API helpers ---- */

    async function apiGet(path, opts = {}) {
      const res = await fetch(path, {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        ...opts,
      });
      return res.json();
    }

    async function apiPost(path, body) {
      const res = await fetch(path, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      return res;
    }

    async function apiPatch(path, body) {
      const res = await fetch(path, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      return res;
    }

    async function apiDelete(path) {
      const res = await fetch(path, { method: "DELETE" });
      return res;
    }

    async function apiGetEvents() {
      return apiGet("/api/events");
    }

    async function apiCreateEvent(payload) {
      const res = await apiPost("/api/events", payload);
      if (!res.ok) throw new Error("Failed to create event");
      return res.json();
    }

    async function apiUpdateEvent(id, payload) {
      const res = await apiPatch(`/api/events/${id}`, payload);
      if (!res.ok) throw new Error("Failed to update event");
    }

    async function apiDeleteEvent(id) {
      const res = await apiDelete(`/api/events/${id}`);
      if (!res.ok) throw new Error("Failed to delete event");
    }

    async function apiGetRounds(eventId) {
      const res = await apiGet(`/api/rounds?event_id=${eventId}`);
      return res;
    }

    async function apiCreateRound(payload) {
      const res = await apiPost("/api/rounds", payload);
      if (!res.ok) throw new Error("Failed to create round");
      return res.json();
    }

    async function apiUpdateRound(id, payload) {
      const res = await apiPatch(`/api/rounds/${id}`, payload);
      if (!res.ok) throw new Error("Failed to update round");
    }

    async function apiDeleteRound(id) {
      const res = await apiDelete(`/api/rounds/${id}`);
      if (!res.ok) throw new Error("Failed to delete round");
    }

    /* ---- Utility helpers ---- */

    function resultLetter(r) {
      if (r === "Win") return "W";
      if (r === "Loss") return "L";
      return "D";
    }

    function computeRecord(rounds) {
      let w = 0, l = 0, d = 0;
      for (const r of rounds) {
        if (r.matchResult === "Win") w++;
        else if (r.matchResult === "Loss") l++;
        else if (r.matchResult === "Draw") d++;
      }
      return d ? `${w}-${l}-${d}` : `${w}-${l}`;
    }

    function groupByName(name) {
      return document.querySelector(`[data-chip-group="${name}"]`);
    }

    function getChipValue(group) {
      if (!group) return null;
      const sel = group.querySelector(".chip.selected");
      return sel ? sel.dataset.value : null;
    }

    function clearChipGroup(group) {
      if (!group) return;
      group.querySelectorAll(".chip").forEach(c => c.classList.remove("selected"));
    }

    function getGameResult(n) {
      return getChipValue(groupByName(`g${n}Result`));
    }

    function getGamePlay(n) {
      return getChipValue(groupByName(`g${n}Play`));
    }

    function getGamesArray() {
      const games = [];
      const g1 = getGameResult(1);
      const g2 = getGameResult(2);
      const g3 = getGameResult(3);

      if (g1) {
        const p1 = getGamePlay(1);
        games.push({ number: 1, result: g1, onPlay: p1 === "1st" ? true : p1 === "2nd" ? false : null });
      }
      if (g2) {
        const p2 = getGamePlay(2);
        games.push({ number: 2, result: g2, onPlay: p2 === "1st" ? true : p2 === "2nd" ? false : null });
      }
      if (g3) {
        const p3 = getGamePlay(3);
        games.push({ number: 3, result: g3, onPlay: p3 === "1st" ? true : p3 === "2nd" ? false : null });
      }
      return games;
    }

    function computeMatch(games) {
      const wins = games.filter(g => g.result === "W").length;
      const losses = games.filter(g => g.result === "L").length;
      if (wins > losses) return "Win";
      if (losses > wins) return "Loss";
      return "Draw";
    }

    /* ---- Detail event deck display helper ---- */
    function updateDetailEventDeckDisplay() {
      const deckEl = document.getElementById("detailEventDeck");
      deckEl.innerHTML = "";

      if (!currentEvent || !currentEvent.yourDeck) {
        return;
      }

      const text = currentEvent.yourDeck;
      const url = currentEvent.linkUrl;

      if (url) {
        const a = document.createElement("a");
        a.textContent = text;
        a.href = url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.style.color = "inherit";
        a.style.textDecoration = "underline";
        deckEl.appendChild(a);
      } else {
        deckEl.textContent = text;
      }
    }

    /* ---- UI: Games visibility & summary ---- */

    function updateGameVisibility() {
      const g1 = getGameResult(1);
      const g2 = getGameResult(2);

      const g2Col = document.getElementById("game2Col");
      const g3Col = document.getElementById("game3Col");

      if (!g1) {
        g2Col.style.display = "none";
        g3Col.style.display = "none";
        clearChipGroup(groupByName("g2Result"));
        clearChipGroup(groupByName("g2Play"));
        clearChipGroup(groupByName("g3Result"));
        clearChipGroup(groupByName("g3Play"));
        return;
      }

      g2Col.style.display = "block";

      if (!g2) {
        g3Col.style.display = "none";
        clearChipGroup(groupByName("g3Result"));
        clearChipGroup(groupByName("g3Play"));
      } else {
        g3Col.style.display = "block";
      }
    }

    function updateMatchSummary() {
      const games = getGamesArray();
      const el = document.getElementById("matchSummary");

      if (games.length === 0) {
        el.textContent = "Set Game 1 to begin. Leaving Game 2/3 empty = Best of 1.";
        return;
      }

      const pattern = games.map(g => g.result).join("");
      const wins = games.filter(g => g.result === "W").length;
      const losses = games.filter(g => g.result === "L").length;
      const result = computeMatch(games);

      el.textContent = `Match: ${result} (${pattern}) ‚Äì ${wins}-${losses}`;
    }

    function initChips() {
      document.querySelectorAll(".chip-group").forEach(group => {
        group.addEventListener("click", e => {
          const chip = e.target.closest(".chip");
          if (!chip) return;

          const already = chip.classList.contains("selected");
          group.querySelectorAll(".chip").forEach(c => c.classList.remove("selected"));
          if (!already) chip.classList.add("selected");

          const name = group.dataset.chipGroup || "";
          if (name.startsWith("g")) {
            updateGameVisibility();
            updateMatchSummary();
          }
        });
      });
    }

    /* ---- Event notes helpers ---- */

    function updateEventNotesViewFromCurrent() {
      const textEl = document.getElementById("eventCommentsText");
      if (!currentEvent || !currentEvent.comments) {
        textEl.textContent = "No event notes yet. Tap üìù to add.";
        textEl.classList.add("empty");
      } else {
        textEl.textContent = currentEvent.comments;
        textEl.classList.remove("empty");
      }
    }

    function showEventNotesOverlay() {
      if (!currentEvent) return;
      const textarea = document.getElementById("eventCommentsInput");
      textarea.value = currentEvent.comments || "";
      document.getElementById("eventNotesOverlay").classList.add("visible");
      document.getElementById("eventNotesSheet").classList.add("visible");
      textarea.focus();
    }

    function hideEventNotesOverlay() {
      document.getElementById("eventNotesSheet").classList.remove("visible");
      document.getElementById("eventNotesOverlay").classList.remove("visible");
    }

    async function handleEventNotesSubmit(e) {
      e.preventDefault();
      if (!currentEvent) return;
      const textarea = document.getElementById("eventCommentsInput");
      const text = textarea.value;
      await apiUpdateEvent(currentEvent.id, { comments: text });
      currentEvent.comments = text;
      updateEventNotesViewFromCurrent();
      hideEventNotesOverlay();
      showToast("‚úÖ Event notes saved");
    }

    /* ---- Auth view ---- */

    function setAuthMode(mode) {
      authMode = mode;
      const title = document.getElementById("authTitle");
      const subtitle = document.getElementById("authSubtitle");
      const toggleText = document.getElementById("authToggleText");
      const toggleBtn = document.getElementById("authToggleBtn");
      const submitBtn = document.getElementById("authSubmitBtn");

      const error = document.getElementById("authError");
      error.style.display = "none";
      error.textContent = "";

      if (mode === "login") {
        title.textContent = "Sign in";
        subtitle.textContent = "Log in to your Riftbound tracker.";
        toggleText.textContent = "Need an account?";
        toggleBtn.textContent = "Register";
        submitBtn.textContent = "Log in";
      } else {
        title.textContent = "Create account";
        subtitle.textContent = "Make an account to track your events.";
        toggleText.textContent = "Already have an account?";
        toggleBtn.textContent = "Log in";
        submitBtn.textContent = "Register";
      }
    }

    async function checkCurrentUser() {
      try {
        const data = await apiGet("/api/me");
        if (data && data.user) {
          currentUser = data.user;
          showAppForUser();
        } else {
          showAuthView();
        }
      } catch (e) {
        showAuthView();
      }
    }

    function showAuthError(message) {
      const error = document.getElementById("authError");
      error.textContent = message;
      error.style.display = "block";
    }

    function clearAuthFields() {
      document.getElementById("authUsername").value = "";
      document.getElementById("authPassword").value = "";
      const error = document.getElementById("authError");
      error.textContent = "";
      error.style.display = "none";
    }

    function showAuthView() {
      document.getElementById("authView").style.display = "block";
      document.getElementById("appShell").style.display = "none";
    }

    function showAppForUser() {
      document.getElementById("authView").style.display = "none";
      document.getElementById("appShell").style.display = "block";

      const name = currentUser ? currentUser.username : "";
      document.getElementById("currentUserLabel").textContent =
        name ? `Signed in as ${name}` : "";
      document.getElementById("userPillName").textContent =
        name ? `@${name}` : "";

      // Show/hide admin button based on role
      const adminBtn = document.getElementById("adminBtn");
      if (currentUser && currentUser.isAdmin) {
        adminBtn.style.display = "inline-block";
      } else {
        adminBtn.style.display = "none";
      }

      renderEvents();
    }

    async function handleAuthSubmit(e) {
      e.preventDefault();
      const username = document.getElementById("authUsername").value.trim();
      const password = document.getElementById("authPassword").value.trim();
      if (!username || !password) {
        showAuthError("Enter both username and password.");
        return;
      }

      try {
        let res;
        if (authMode === "login") {
          res = await apiPost("/api/login", { username, password });
        } else {
          res = await apiPost("/api/register", { username, password });
        }

        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          showAuthError(data.error || "Something went wrong.");
          return;
        }

        const user = await res.json();
        currentUser = user;
        clearAuthFields();
        showAppForUser();
      } catch (err) {
        console.error(err);
        showAuthError("Server error. Check console/logs.");
      }
    }

    async function handleLogout() {
      try {
        await apiPost("/api/logout", {});
      } catch (e) {
        // ignore
      }
      currentUser = null;
      currentEvent = null;
      currentRounds = [];
      currentDetailRound = null;
      editingRoundId = null;
      showAuthView();
    }

    /* ---- Password Reset ---- */

    function showResetRequestError(message) {
      const error = document.getElementById("resetRequestError");
      error.textContent = message;
      error.style.display = "block";
    }

    function showResetConfirmError(message) {
      const error = document.getElementById("resetConfirmError");
      error.textContent = message;
      error.style.display = "block";
    }

    function showResetRequestOverlay() {
      document.getElementById("resetUsername").value = "";
      const error = document.getElementById("resetRequestError");
      error.textContent = "";
      error.style.display = "none";
      document.getElementById("resetRequestOverlay").classList.add("visible");
      document.querySelector("#resetRequestOverlay .sheet").classList.add("visible");
    }

    function hideResetRequestOverlay() {
      document.querySelector("#resetRequestOverlay .sheet").classList.remove("visible");
      document.getElementById("resetRequestOverlay").classList.remove("visible");
    }

    function showResetTokenOverlay(token) {
      document.getElementById("displayToken").value = token;
      document.getElementById("resetTokenOverlay").classList.add("visible");
      document.querySelector("#resetTokenOverlay .sheet").classList.add("visible");
    }

    function hideResetTokenOverlay() {
      document.querySelector("#resetTokenOverlay .sheet").classList.remove("visible");
      document.getElementById("resetTokenOverlay").classList.remove("visible");
    }

    function showResetConfirmOverlay(token) {
      if (token) {
        document.getElementById("resetToken").value = token;
      } else {
        document.getElementById("resetToken").value = "";
      }
      document.getElementById("resetNewPassword").value = "";
      const error = document.getElementById("resetConfirmError");
      error.textContent = "";
      error.style.display = "none";
      document.getElementById("resetConfirmOverlay").classList.add("visible");
      document.querySelector("#resetConfirmOverlay .sheet").classList.add("visible");
    }

    function hideResetConfirmOverlay() {
      document.querySelector("#resetConfirmOverlay .sheet").classList.remove("visible");
      document.getElementById("resetConfirmOverlay").classList.remove("visible");
    }

    async function handleResetRequest(e) {
      e.preventDefault();
      const username = document.getElementById("resetUsername").value.trim();

      if (!username) {
        showResetRequestError("Enter your username.");
        return;
      }

      try {
        const res = await apiPost("/api/password-reset/request", { username });

        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          showResetRequestError(data.error || "Failed to generate token.");
          return;
        }

        const data = await res.json();
        hideResetRequestOverlay();
        showResetTokenOverlay(data.token);
      } catch (err) {
        console.error(err);
        showResetRequestError("Server error. Check console/logs.");
      }
    }

    async function handleResetConfirm(e) {
      e.preventDefault();
      const token = document.getElementById("resetToken").value.trim();
      const newPassword = document.getElementById("resetNewPassword").value;

      if (!token || !newPassword) {
        showResetConfirmError("Enter both token and new password.");
        return;
      }

      try {
        const res = await apiPost("/api/password-reset/confirm", {
          token,
          newPassword
        });

        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          showResetConfirmError(data.error || "Failed to reset password.");
          return;
        }

        hideResetConfirmOverlay();
        hideResetTokenOverlay();
        alert("Password reset successful! You can now log in with your new password.");
      } catch (err) {
        console.error(err);
        showResetConfirmError("Server error. Check console/logs.");
      }
    }

    /* ---- Admin Panel ---- */

    function showAdminPanel() {
      document.getElementById("adminOverlay").classList.add("visible");
      document.getElementById("adminSheet").classList.add("visible");
      loadPendingResetRequests();
    }

    function hideAdminPanel() {
      document.getElementById("adminSheet").classList.remove("visible");
      document.getElementById("adminOverlay").classList.remove("visible");
    }

    async function loadPendingResetRequests() {
      const container = document.getElementById("adminPendingRequests");
      container.innerHTML = "<div style='padding: 10px; color: var(--muted);'>Loading...</div>";

      try {
        const requests = await apiGet("/api/admin/password-reset-requests");

        if (!requests || requests.length === 0) {
          container.innerHTML = "<div style='padding: 10px; color: var(--muted); font-size: 0.85rem;'>No pending password reset requests.</div>";
          return;
        }

        container.innerHTML = "";
        requests.forEach(req => {
          const card = document.createElement("div");
          card.style.cssText = "background: var(--card); border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; margin-bottom: 10px;";

          const username = document.createElement("div");
          username.style.cssText = "font-weight: 600; font-size: 0.95rem; margin-bottom: 4px;";
          username.textContent = `Username: ${req.username}`;

          const token = document.createElement("div");
          token.style.cssText = "font-size: 0.75rem; color: var(--muted); margin-bottom: 4px; word-break: break-all; font-family: monospace;";
          token.textContent = `Token: ${req.token}`;

          const created = document.createElement("div");
          created.style.cssText = "font-size: 0.75rem; color: var(--muted); margin-bottom: 8px;";
          const createdDate = new Date(req.createdAt).toLocaleString();
          created.textContent = `Requested: ${createdDate}`;

          const actions = document.createElement("div");
          actions.style.cssText = "display: flex; gap: 8px;";

          const approveBtn = document.createElement("button");
          approveBtn.className = "btn btn-primary";
          approveBtn.textContent = "Approve";
          approveBtn.style.flex = "1";
          approveBtn.onclick = async () => {
            if (confirm(`Approve password reset for ${req.username}?`)) {
              await approveResetRequest(req.id);
            }
          };

          const denyBtn = document.createElement("button");
          denyBtn.className = "btn btn-secondary";
          denyBtn.textContent = "Deny";
          denyBtn.style.flex = "1";
          denyBtn.onclick = async () => {
            if (confirm(`Deny password reset for ${req.username}?`)) {
              await denyResetRequest(req.id);
            }
          };

          actions.appendChild(approveBtn);
          actions.appendChild(denyBtn);

          card.appendChild(username);
          card.appendChild(token);
          card.appendChild(created);
          card.appendChild(actions);

          container.appendChild(card);
        });
      } catch (err) {
        console.error(err);
        container.innerHTML = "<div style='padding: 10px; color: #b91c1c; font-size: 0.85rem;'>Error loading requests.</div>";
      }
    }

    async function approveResetRequest(requestId) {
      try {
        const res = await apiPost(`/api/admin/password-reset-requests/${requestId}/approve`, {});
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          alert(data.error || "Failed to approve request.");
          return;
        }
        alert("Request approved! User can now use their token to reset password.");
        loadPendingResetRequests();
      } catch (err) {
        console.error(err);
        alert("Server error. Check console/logs.");
      }
    }

    async function denyResetRequest(requestId) {
      try {
        const res = await apiPost(`/api/admin/password-reset-requests/${requestId}/deny`, {});
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          alert(data.error || "Failed to deny request.");
          return;
        }
        alert("Request denied and deleted.");
        loadPendingResetRequests();
      } catch (err) {
        console.error(err);
        alert("Server error. Check console/logs.");
      }
    }

    function switchAdminTab(tab) {
      // Update tab buttons
      document.querySelectorAll(".admin-tab").forEach(btn => {
        btn.classList.remove("active");
        btn.style.borderBottom = "2px solid transparent";
        btn.style.fontWeight = "normal";
      });

      // Update content
      document.querySelectorAll(".admin-tab-content").forEach(content => {
        content.style.display = "none";
      });

      if (tab === "resets") {
        document.getElementById("adminTabResets").classList.add("active");
        document.getElementById("adminTabResets").style.borderBottom = "2px solid var(--accent)";
        document.getElementById("adminTabResets").style.fontWeight = "600";
        document.getElementById("adminResetsContent").style.display = "block";
        loadPendingResetRequests();
      } else if (tab === "users") {
        document.getElementById("adminTabUsers").classList.add("active");
        document.getElementById("adminTabUsers").style.borderBottom = "2px solid var(--accent)";
        document.getElementById("adminTabUsers").style.fontWeight = "600";
        document.getElementById("adminUsersContent").style.display = "block";
        loadUsersList();
      }
    }

    async function loadUsersList() {
      const container = document.getElementById("adminUsersList");
      container.innerHTML = "<div style='padding: 10px; color: var(--muted);'>Loading...</div>";

      try {
        const users = await apiGet("/api/admin/users");

        if (!users || users.length === 0) {
          container.innerHTML = "<div style='padding: 10px; color: var(--muted); font-size: 0.85rem;'>No users found.</div>";
          return;
        }

        container.innerHTML = "";
        users.forEach(user => {
          const card = document.createElement("div");
          card.style.cssText = "background: var(--card); border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;";

          const info = document.createElement("div");
          const username = document.createElement("div");
          username.style.cssText = "font-weight: 600; font-size: 0.95rem; margin-bottom: 2px;";
          username.textContent = user.username;

          const role = document.createElement("div");
          role.style.cssText = "font-size: 0.75rem; color: var(--muted);";
          role.textContent = user.isAdmin ? "Role: Admin" : "Role: User";

          info.appendChild(username);
          info.appendChild(role);

          const actions = document.createElement("div");
          actions.style.cssText = "display: flex; gap: 8px;";

          if (user.isAdmin) {
            const revokeBtn = document.createElement("button");
            revokeBtn.className = "btn btn-secondary";
            revokeBtn.textContent = "Revoke Admin";
            revokeBtn.style.fontSize = "0.8rem";
            revokeBtn.style.padding = "6px 12px";
            revokeBtn.onclick = async () => {
              if (confirm(`Revoke admin access for ${user.username}?`)) {
                await setUserAdmin(user.id, false);
              }
            };
            actions.appendChild(revokeBtn);
          } else {
            const promoteBtn = document.createElement("button");
            promoteBtn.className = "btn btn-primary";
            promoteBtn.textContent = "Make Admin";
            promoteBtn.style.fontSize = "0.8rem";
            promoteBtn.style.padding = "6px 12px";
            promoteBtn.onclick = async () => {
              if (confirm(`Grant admin access to ${user.username}?`)) {
                await setUserAdmin(user.id, true);
              }
            };
            actions.appendChild(promoteBtn);
          }

          card.appendChild(info);
          card.appendChild(actions);

          container.appendChild(card);
        });
      } catch (err) {
        console.error(err);
        container.innerHTML = "<div style='padding: 10px; color: #b91c1c; font-size: 0.85rem;'>Error loading users. You may not have admin access.</div>";
      }
    }

    async function setUserAdmin(userId, isAdmin) {
      try {
        const res = await apiPost(`/api/admin/users/${userId}/set-admin`, { isAdmin });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          alert(data.error || "Failed to update user role.");
          return;
        }
        alert(`User role updated successfully!`);
        loadUsersList();
      } catch (err) {
        console.error(err);
        alert("Server error. Check console/logs.");
      }
    }

    /* ---- Stats ---- */

    function showStatsOverlay() {
      document.getElementById("statsOverlay").classList.add("visible");
      document.getElementById("statsSheet").classList.add("visible");
      statsMode = "matches"; // Reset to matches when opening
      switchStatsTab("matches");
      loadStatsGrid();
    }

    function hideStatsOverlay() {
      document.getElementById("statsSheet").classList.remove("visible");
      document.getElementById("statsOverlay").classList.remove("visible");
    }

    function switchStatsTab(mode) {
      statsMode = mode;

      // Update tab buttons
      document.querySelectorAll(".stats-tab").forEach(btn => {
        btn.style.borderBottom = "2px solid transparent";
        btn.style.fontWeight = "normal";
      });

      if (mode === "matches") {
        document.getElementById("statsTabMatches").style.borderBottom = "2px solid var(--accent)";
        document.getElementById("statsTabMatches").style.fontWeight = "600";
      } else if (mode === "games") {
        document.getElementById("statsTabGames").style.borderBottom = "2px solid var(--accent)";
        document.getElementById("statsTabGames").style.fontWeight = "600";
      }

      loadStatsGrid();
    }

    function getWinRateColor(winRate) {
      // Convert win rate (0-1) to a color gradient from dark red to dark green
      // 0% = dark red (#991b1b)
      // 50% = yellow (#fef08a)
      // 100% = dark green (#166534)

      let r, g, b;

      if (winRate < 0.5) {
        // Interpolate from dark red to yellow
        const t = winRate * 2; // 0 to 1
        r = Math.round(153 + (254 - 153) * t); // 153 (#991b1b) to 254 (#fef08a)
        g = Math.round(27 + (240 - 27) * t);   // 27 to 240
        b = Math.round(27 + (138 - 27) * t);   // 27 to 138
      } else {
        // Interpolate from yellow to dark green
        const t = (winRate - 0.5) * 2; // 0 to 1
        r = Math.round(254 + (22 - 254) * t);  // 254 to 22 (#166534)
        g = Math.round(240 + (101 - 240) * t); // 240 to 101
        b = Math.round(138 + (52 - 138) * t);  // 138 to 52
      }

      return `rgb(${r}, ${g}, ${b})`;
    }

    async function loadStatsGrid() {
      const container = document.getElementById("statsGridContent");
      container.innerHTML = "<div style='padding: 20px; text-align: center; color: var(--muted);'>Loading stats...</div>";

      try {
        // Build query string with date range if set
        const startDate = document.getElementById("statsStartDate").value;
        const endDate = document.getElementById("statsEndDate").value;

        let url = "/api/stats";
        const params = new URLSearchParams();
        if (startDate) params.append("startDate", startDate);
        if (endDate) params.append("endDate", endDate);
        if (params.toString()) url += "?" + params.toString();

        const data = await apiGet(url);
        const { matchStats, gameStats, allDecks } = data;

        // Choose which stats to display based on current mode
        const stats = statsMode === "matches" ? matchStats : gameStats;

        if (!stats || stats.length === 0) {
          const modeLabel = statsMode === "matches" ? "match" : "game";
          container.innerHTML = `<div style='padding: 20px; text-align: center; color: var(--muted);'>No ${modeLabel} data yet. Play some rounds to see stats!</div>`;
          return;
        }

        // Build a map for quick lookup: yourDeck -> oppDeck -> stats
        const statsMap = {};
        stats.forEach(s => {
          if (!statsMap[s.yourDeck]) {
            statsMap[s.yourDeck] = {};
          }
          statsMap[s.yourDeck][s.oppDeck] = s;
        });

        // Get unique decks for rows (your decks) and columns (opp decks)
        const yourDecks = [...new Set(stats.map(s => s.yourDeck))].sort();
        const oppDecks = [...new Set(stats.map(s => s.oppDeck))].sort();

        // Create grid
        const numCols = oppDecks.length + 1; // +1 for row header
        const grid = document.createElement("div");
        grid.className = "stats-grid";
        grid.style.gridTemplateColumns = `150px repeat(${oppDecks.length}, 100px)`;

        // Header row
        const cornerCell = document.createElement("div");
        cornerCell.className = "stats-cell stats-header";
        cornerCell.textContent = "Your Deck ‚Üì / Opp ‚Üí";
        cornerCell.style.fontSize = "0.7rem";
        grid.appendChild(cornerCell);

        oppDecks.forEach(oppDeck => {
          const headerCell = document.createElement("div");
          headerCell.className = "stats-cell stats-header";
          headerCell.textContent = oppDeck;
          headerCell.style.fontSize = "0.8rem";
          headerCell.style.wordWrap = "break-word";
          grid.appendChild(headerCell);
        });

        // Data rows
        yourDecks.forEach(yourDeck => {
          // Row header
          const rowHeader = document.createElement("div");
          rowHeader.className = "stats-cell stats-row-header";
          rowHeader.textContent = yourDeck;
          rowHeader.style.fontSize = "0.85rem";
          rowHeader.style.textAlign = "left";
          grid.appendChild(rowHeader);

          // Data cells
          oppDecks.forEach(oppDeck => {
            const cell = document.createElement("div");
            cell.className = "stats-cell";

            const matchup = statsMap[yourDeck]?.[oppDeck];

            if (matchup) {
              cell.classList.add("stats-data-cell");
              const winRate = matchup.winRate;
              const winRatePercent = Math.round(winRate * 100);

              // Apply color gradient
              cell.style.backgroundColor = getWinRateColor(winRate);
              cell.style.color = winRate > 0.3 && winRate < 0.7 ? "#000" : "#fff";
              cell.style.fontWeight = "600";

              cell.textContent = `${winRatePercent}% (${matchup.total})`;
              const modeLabel = statsMode === "matches" ? "matches" : "games";
              cell.title = `${yourDeck} vs ${oppDeck}\nWin Rate: ${winRatePercent}%\nRecord: ${matchup.wins}-${matchup.losses}${matchup.draws > 0 ? '-' + matchup.draws : ''}\nTotal: ${matchup.total} ${modeLabel}`;
            } else {
              cell.classList.add("stats-empty");
              cell.textContent = "‚Äî";
            }

            grid.appendChild(cell);
          });
        });

        container.innerHTML = "";
        container.appendChild(grid);

        // Also render mobile view
        renderMobileStatsView(stats, yourDecks);
      } catch (err) {
        console.error(err);
        container.innerHTML = "<div style='padding: 20px; text-align: center; color: #b91c1c;'>Error loading stats. Check console.</div>";
      }
    }

    function renderMobileStatsView(stats, yourDecks) {
      // Store stats for later use by dropdown
      currentStatsData = stats;

      const selector = document.getElementById("statsMobileDeckSelect");
      const mobileContent = document.getElementById("statsMobileContent");

      // Populate deck selector
      selector.innerHTML = '<option value="">-- Select a deck --</option>';
      yourDecks.forEach(deck => {
        const option = document.createElement("option");
        option.value = deck;
        option.textContent = deck;
        selector.appendChild(option);
      });

      // Initial render
      renderMobileCards(stats, "");
    }

    function renderMobileCards(stats, selectedDeck) {
      const mobileContent = document.getElementById("statsMobileContent");

      if (!selectedDeck) {
        mobileContent.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">Select a deck to view matchups</div>';
        return;
      }

      // Filter stats for selected deck
      const deckStats = stats.filter(s => s.yourDeck === selectedDeck);

      if (deckStats.length === 0) {
        mobileContent.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">No matchup data for this deck</div>';
        return;
      }

      // Sort by win rate descending
      deckStats.sort((a, b) => b.winRate - a.winRate);

      mobileContent.innerHTML = "";
      deckStats.forEach(matchup => {
        const card = document.createElement("div");
        card.className = "stats-matchup-card";

        const winRate = matchup.winRate;
        const winRatePercent = Math.round(winRate * 100);
        const borderColor = getWinRateColor(winRate);
        card.style.borderLeftColor = borderColor;

        const header = document.createElement("div");
        header.className = "stats-matchup-header";
        header.textContent = `vs ${matchup.oppDeck}`;

        const details = document.createElement("div");
        details.className = "stats-matchup-details";

        const record = document.createElement("span");
        record.textContent = `${matchup.wins}-${matchup.losses}${matchup.draws > 0 ? '-' + matchup.draws : ''}`;

        const winrateSpan = document.createElement("span");
        winrateSpan.className = "stats-matchup-winrate";
        winrateSpan.style.color = borderColor;
        winrateSpan.textContent = `${winRatePercent}% (${matchup.total})`;

        details.appendChild(record);
        details.appendChild(winrateSpan);

        card.appendChild(header);
        card.appendChild(details);

        mobileContent.appendChild(card);
      });
    }

    /* ---- Events view ---- */

    function showEventsView() {
      document.getElementById("eventsView").style.display = "block";
      document.getElementById("eventDetailView").style.display = "none";

      document.getElementById("eventOverlay").classList.remove("visible");
      document.getElementById("roundOverlay").classList.remove("visible");
      document.getElementById("roundDetailOverlay").classList.remove("visible");
      document.getElementById("eventNotesOverlay").classList.remove("visible");
      document.getElementById("eventEditSheet").classList.remove("visible");
      document.getElementById("roundSheet").classList.remove("visible");
      document.getElementById("roundDetailSheet").classList.remove("visible");
      document.getElementById("eventNotesSheet").classList.remove("visible");

      currentEvent = null;
      currentDetailRound = null;
      editingRoundId = null;
    }

    function showEventDetailView() {
      document.getElementById("eventsView").style.display = "none";
      document.getElementById("eventDetailView").style.display = "block";
    }

    async function renderEvents() {
      const body = document.getElementById("eventsBody");
      body.innerHTML = "";
      let events;

      try {
        events = await apiGetEvents();
      } catch (e) {
        body.innerHTML =
          '<div style="padding:8px 18px 10px;font-size:0.85rem;color:#b91c1c;">Error loading events (maybe not logged in).</div>';
        return;
      }

      if (!events.length) {
        const empty = document.createElement("div");
        empty.style.padding = "8px 18px 10px";
        empty.style.fontSize = "0.85rem";
        empty.style.color = "#6b7280";
        empty.textContent = "No events yet. Add one to get started.";
        body.appendChild(empty);
        return;
      }

      events.forEach(ev => {
        const row = document.createElement("div");
        row.className = "event-row";

        const left = document.createElement("div");
        const nameEl = document.createElement("div");
        nameEl.className = "event-name";
        nameEl.textContent = ev.name;
        const deckEl = document.createElement("div");
        deckEl.className = "event-deck";
        deckEl.textContent = ev.yourDeck ? ev.yourDeck : "";
        left.appendChild(nameEl);
        if (ev.yourDeck) left.appendChild(deckEl);

        const wrap = document.createElement("div");
        wrap.className = "event-record-wrap";

        const recEl = document.createElement("div");
        recEl.className = "event-record";
        recEl.textContent = ev.record || "0-0";

        const delEl = document.createElement("div");
        delEl.className = "event-delete";
        delEl.textContent = "Delete";
        delEl.onclick = async (e) => {
          e.stopPropagation();
          if (confirm("Delete this event and all its rounds?")) {
            try {
              await apiDeleteEvent(ev.id);
              if (currentEvent && currentEvent.id === ev.id) {
                showEventsView();
              }
              renderEvents();
            } catch (err) {
              alert("Failed to delete event.");
            }
          }
        };

        wrap.appendChild(recEl);
        wrap.appendChild(delEl);

        row.appendChild(left);
        row.appendChild(wrap);

        row.addEventListener("click", () => openEvent(ev));
        body.appendChild(row);
      });
    }

    function showEventSheet() {
      document.getElementById("eventSheet").classList.add("visible");
    }

    function hideEventSheet() {
      document.getElementById("eventSheet").classList.remove("visible");
    }

    async function handleEventSubmit(e) {
      e.preventDefault();
      const nameInput = document.getElementById("eventName");
      const deckInput = document.getElementById("eventDeck");
      const dateInput = document.getElementById("eventDate");
      const urlInput  = document.getElementById("eventUrl");

      const name = nameInput.value.trim();
      const deck = deckInput.value.trim();
      const date = dateInput.value.trim();
      const url  = urlInput.value.trim();

      if (!name || !deck) {
        alert("Enter both an event name and your deck.");
        return;
      }

      try {
        const ev = await apiCreateEvent({
          name,
          yourDeck: deck,
          eventDate: date || null,
          linkUrl: url || null,
        });

        nameInput.value = "";
        deckInput.value = "";
        dateInput.value = "";
        urlInput.value = "";
        hideEventSheet();
        await renderEvents();
        openEvent(ev);
      } catch (err) {
        alert("Failed to create event.");
      }
    }

    /* ---- Event detail view (rounds) ---- */

    async function openEvent(ev) {
      currentEvent = ev;
      document.getElementById("detailEventName").textContent = ev.name;
      currentEvent.yourDeck = ev.yourDeck;
      currentEvent.linkUrl = ev.linkUrl;
      updateDetailEventDeckDisplay();

      updateEventNotesViewFromCurrent();
      showEventDetailView();
      await renderRoundsForCurrentEvent();
    }

    async function renderRoundsForCurrentEvent() {
      if (!currentEvent) return;
      let rounds;
      try {
        rounds = await apiGetRounds(currentEvent.id);
      } catch (e) {
        document.getElementById("roundsBody").innerHTML =
          '<div style="padding:8px 18px 10px;font-size:0.85rem;color:#b91c1c;">Error loading rounds.</div>';
        return;
      }

      currentRounds = rounds;

      const body = document.getElementById("roundsBody");
      body.innerHTML = "";

      rounds.sort((a, b) => a.roundNumber - b.roundNumber);

      rounds.forEach(r => {
        const row = document.createElement("div");
        row.className = "round-row";
        if (r.matchResult === "Win") row.classList.add("row-win");
        else if (r.matchResult === "Loss") row.classList.add("row-loss");
        else row.classList.add("row-draw");

        const left = document.createElement("div");
        left.className = "round-roundnum";
        const roundNumSpan = document.createElement("span");
        roundNumSpan.textContent = r.roundNumber;
        left.appendChild(roundNumSpan);
        if (r.dieRollWon) {
          const dieSpan = document.createElement("span");
          dieSpan.className = "die";
          dieSpan.textContent = "üé≤";
          left.appendChild(dieSpan);
        }

        const mid = document.createElement("div");
        const deckName = document.createElement("div");
        deckName.className = "round-deck-main";
        deckName.textContent = r.oppDeck || "Unknown";
        mid.appendChild(deckName);

        const actions = document.createElement("div");
        actions.className = "round-actions";

        const editEl = document.createElement("span");
        editEl.className = "round-edit-btn";
        editEl.textContent = "‚úèÔ∏è Edit";
        editEl.onclick = (e) => {
          e.stopPropagation();
          openRoundForEdit(r);
        };

        const delEl = document.createElement("span");
        delEl.className = "round-delete-btn";
        delEl.textContent = "Delete";
        delEl.onclick = async (e) => {
          e.stopPropagation();
          if (confirm("Delete this round?")) {
            try {
              await apiDeleteRound(r.id);
              renderRoundsForCurrentEvent();
            } catch (err) {
              alert("Failed to delete round.");
            }
          }
        };

        actions.appendChild(editEl);
        actions.appendChild(document.createTextNode(" ¬∑ "));
        actions.appendChild(delEl);
        mid.appendChild(actions);

        const right = document.createElement("div");
        right.className = "round-result";
        const main = document.createElement("div");
        main.className = "result-main-letter";
        main.textContent = resultLetter(r.matchResult);
        right.appendChild(main);

        const pattern = (r.games || []).map(g => g.result).join("");
        if (pattern) {
          const p = document.createElement("div");
          p.className = "result-pattern";
          p.textContent = pattern;
          right.appendChild(p);
        }

        row.appendChild(left);
        row.appendChild(mid);
        row.appendChild(right);

        row.addEventListener("click", () => showRoundDetails(r));
        body.appendChild(row);
      });

      document.getElementById("detailRecordDisplay").textContent = computeRecord(rounds);
    }

    async function exportRoundsToText() {
      if (!currentEvent || !currentRounds) return;

      let text = "";

      const deckName = currentEvent.yourDeck || "Unknown Deck";
      const record = computeRecord(currentRounds);
      text += `${deckName} - ${record}\n\n`;

      if (currentRounds.length === 0) {
        text += `No rounds recorded yet.\n`;
      } else {
        currentRounds.forEach(round => {
          text += `R${round.roundNumber} - `;

          // Add game results as emoji sequence
          if (round.games && round.games.length > 0) {
            round.games.forEach(game => {
              const emoji = game.result === "W" ? "‚úÖ" : game.result === "L" ? "‚ùå" : "‚öñÔ∏è";
              text += emoji;
            });
          }

          text += ` ${round.oppDeck || "Unknown"}`;

          // Add die roll emoji if won
          if (round.dieRollWon) {
            text += ` üé≤`;
          }

          text += `\n`;
        });
      }

      try {
        await navigator.clipboard.writeText(text);
        showToast("üìã Copied to clipboard");
      } catch (err) {
        console.error("Failed to copy to clipboard:", err);
        alert("‚ùå Failed to copy to clipboard. Text:\n\n" + text);
      }
    }

    /* ---- Event edit overlay ---- */

    function showEventEditSheet() {
      if (!currentEvent) return;
      document.getElementById("eventEditName").value = currentEvent.name || "";
      document.getElementById("eventEditDeck").value = currentEvent.yourDeck || "";
      document.getElementById("eventEditDate").value = currentEvent.eventDate || "";
      document.getElementById("eventEditUrl").value = currentEvent.linkUrl || "";
      document.getElementById("eventOverlay").classList.add("visible");
      document.getElementById("eventEditSheet").classList.add("visible");
    }

    function hideEventEditSheet() {
      document.getElementById("eventEditSheet").classList.remove("visible");
      document.getElementById("eventOverlay").classList.remove("visible");
    }

    async function handleEventEditSubmit(e) {
      e.preventDefault();
      if (!currentEvent) return;

      const name = document.getElementById("eventEditName").value.trim();
      const deck = document.getElementById("eventEditDeck").value.trim();
      const date = document.getElementById("eventEditDate").value.trim();
      const url  = document.getElementById("eventEditUrl").value.trim();

      if (!name || !deck) {
        alert("Event name and your deck cannot be empty.");
        return;
      }

      try {
        await apiUpdateEvent(currentEvent.id, {
          name,
          yourDeck: deck,
          eventDate: date || null,
          linkUrl: url || null,
        });
      } catch (err) {
        alert("Failed to update event.");
        return;
      }

      currentEvent.name = name;
      currentEvent.yourDeck = deck;
      currentEvent.eventDate = date || null;
      currentEvent.linkUrl = url || null;

      document.getElementById("detailEventName").textContent = name;
      updateDetailEventDeckDisplay();

      hideEventEditSheet();
      renderEvents();
    }

    /* ---- Round Add/Edit ---- */

    function resetRoundFormForCreate() {
      editingRoundId = null;
      document.getElementById("saveRoundBtn").textContent = "Add round";
      document.getElementById("roundNumber").value = (currentRounds.length || 0) + 1;
      document.getElementById("oppDeck").value = "";
      document.getElementById("dieRollWon").checked = false;
      ["g1Result","g1Play","g2Result","g2Play","g3Result","g3Play"].forEach(name =>
        clearChipGroup(groupByName(name))
      );
      updateGameVisibility();
      updateMatchSummary();
      updateSheetRoundLabel();
    }

    function showRoundSheet() {
      document.getElementById("roundDetailOverlay").classList.remove("visible");
      document.getElementById("roundDetailSheet").classList.remove("visible");
      document.getElementById("roundOverlay").classList.add("visible");
      document.getElementById("roundSheet").classList.add("visible");
    }

    function hideRoundSheet() {
      document.getElementById("roundSheet").classList.remove("visible");
      document.getElementById("roundOverlay").classList.remove("visible");
      editingRoundId = null;
      document.getElementById("saveRoundBtn").textContent = "Add round";
    }

    function openRoundForCreate() {
      resetRoundFormForCreate();
      showRoundSheet();
    }

    function openRoundForEdit(round) {
      editingRoundId = round.id;
      document.getElementById("saveRoundBtn").textContent = "Save changes";
      document.getElementById("roundNumber").value = round.roundNumber;
      document.getElementById("oppDeck").value = round.oppDeck || "";
      document.getElementById("dieRollWon").checked = !!round.dieRollWon;

      ["g1Result","g1Play","g2Result","g2Play","g3Result","g3Play"].forEach(name =>
        clearChipGroup(groupByName(name))
      );

      const gamesByNum = {};
      (round.games || []).forEach(g => { gamesByNum[g.number] = g; });

      [1,2,3].forEach(n => {
        const g = gamesByNum[n];
        if (g) {
          const resGroup = groupByName(`g${n}Result`);
          const playGroup = groupByName(`g${n}Play`);
          if (resGroup) {
            resGroup.querySelectorAll(".chip").forEach(ch => {
              if (ch.dataset.value === g.result) ch.classList.add("selected");
            });
          }
          if (playGroup) {
            const val = g.onPlay === true ? "1st" : g.onPlay === false ? "2nd" : null;
            if (val !== null) {
              playGroup.querySelectorAll(".chip").forEach(ch => {
                if (ch.dataset.value === val) ch.classList.add("selected");
              });
            }
          }
        }
      });

      updateGameVisibility();
      updateMatchSummary();
      updateSheetRoundLabel();
      showRoundSheet();
    }

    /* ---- Round detail & comments ---- */

    function showRoundDetails(round) {
      hideRoundSheet();
      currentDetailRound = round;

      document.getElementById("roundDetailTitle").textContent = `Round ${round.roundNumber}`;
      document.getElementById("roundDetailOppDeck").textContent =
        round.oppDeck || "Unknown deck";

      const die = round.dieRollWon ? "You won the die roll." :
        "You did not win the die roll (or went second).";
      document.getElementById("roundDetailDieRoll").textContent = die;

      const gamesDiv = document.getElementById("roundDetailGames");
      gamesDiv.innerHTML = "";
      (round.games || []).forEach(g => {
        const line = document.createElement("div");
        const play = g.onPlay === true ? "1st" : g.onPlay === false ? "2nd" : "Not specified";
        line.textContent = `Game ${g.number}: ${g.result} (${play})`;
        gamesDiv.appendChild(line);
      });

      if (!round.games || !round.games.length) {
        const line = document.createElement("div");
        line.textContent = "No games recorded.";
        gamesDiv.appendChild(line);
      }

      document.getElementById("roundDetailComments").value = round.comments || "";

      document.getElementById("roundDetailOverlay").classList.add("visible");
      document.getElementById("roundDetailSheet").classList.add("visible");
    }

    function hideRoundDetails() {
      document.getElementById("roundDetailSheet").classList.remove("visible");
      document.getElementById("roundDetailOverlay").classList.remove("visible");
      currentDetailRound = null;
    }

    async function saveRoundComments() {
      if (!currentDetailRound) return;
      const text = document.getElementById("roundDetailComments").value;
      try {
        await apiUpdateRound(currentDetailRound.id, { comments: text });
      } catch (err) {
        alert("Failed to save notes.");
        return;
      }
      currentDetailRound.comments = text;
      alert("Round notes saved.");
    }

    function updateSheetRoundLabel() {
      const n = document.getElementById("roundNumber").value || "1";
      const prefix = editingRoundId ? "Edit Round" : "Round";
      document.getElementById("roundSheetTitle").textContent = `${prefix} ${n}`;
    }

    async function handleRoundSubmit(e) {
      e.preventDefault();
      if (!currentEvent) {
        alert("Select an event first.");
        return;
      }

      const roundNumber = parseInt(document.getElementById("roundNumber").value, 10);
      const oppDeck = document.getElementById("oppDeck").value.trim();
      const dieRollWon = document.getElementById("dieRollWon").checked;

      if (!oppDeck) {
        alert("Enter opponent deck.");
        return;
      }

      const games = getGamesArray();
      if (games.length === 0) {
        alert("Set at least Game 1 result.");
        return;
      }

      try {
        if (editingRoundId) {
          await apiUpdateRound(editingRoundId, {
            roundNumber,
            oppDeck,
            dieRollWon,
            games,
          });
        } else {
          await apiCreateRound({
            eventId: currentEvent.id,
            roundNumber,
            oppDeck,
            games,
            dieRollWon,
          });
        }
      } catch (err) {
        alert("Failed to save round.");
        return;
      }

      hideRoundSheet();

      if (!editingRoundId) {
        document.getElementById("roundNumber").value = roundNumber + 1;
      }
      editingRoundId = null;
      document.getElementById("saveRoundBtn").textContent = "Add round";

      document.getElementById("oppDeck").value = "";
      document.getElementById("dieRollWon").checked = false;
      ["g1Result","g1Play","g2Result","g2Play","g3Result","g3Play"].forEach(name =>
        clearChipGroup(groupByName(name))
      );
      updateGameVisibility();
      updateMatchSummary();

      renderRoundsForCurrentEvent();
    }

    /* ---- Init ---- */

    document.addEventListener("DOMContentLoaded", () => {
      initChips();
      updateSheetRoundLabel();
      updateGameVisibility();
      updateMatchSummary();

      // Auth UI wiring
      setAuthMode("login");
      document.getElementById("authToggleBtn").onclick = () => {
        setAuthMode(authMode === "login" ? "register" : "login");
      };
      document.getElementById("authForm").onsubmit = handleAuthSubmit;
      document.getElementById("authCancelBtn").onclick = clearAuthFields;
      document.getElementById("logoutBtn").onclick = handleLogout;
      document.getElementById("statsBtn").onclick = showStatsOverlay;
      document.getElementById("closeStatsBtn").onclick = hideStatsOverlay;
      document.getElementById("statsTabMatches").onclick = () => switchStatsTab("matches");
      document.getElementById("statsTabGames").onclick = () => switchStatsTab("games");
      document.getElementById("statsApplyDateRange").onclick = loadStatsGrid;
      document.getElementById("statsClearDateRange").onclick = () => {
        document.getElementById("statsStartDate").value = "";
        document.getElementById("statsEndDate").value = "";
        loadStatsGrid();
      };
      document.getElementById("statsMobileDeckSelect").onchange = (e) => {
        renderMobileCards(currentStatsData, e.target.value);
      };
      document.getElementById("adminBtn").onclick = showAdminPanel;
      document.getElementById("closeAdminBtn").onclick = hideAdminPanel;
      document.getElementById("adminTabResets").onclick = () => switchAdminTab("resets");
      document.getElementById("adminTabUsers").onclick = () => switchAdminTab("users");

      // Password reset UI wiring
      document.getElementById("forgotPasswordBtn").onclick = showResetRequestOverlay;
      document.getElementById("resetRequestForm").onsubmit = handleResetRequest;
      document.getElementById("cancelResetRequestBtn").onclick = hideResetRequestOverlay;
      document.getElementById("closeTokenBtn").onclick = hideResetTokenOverlay;
      document.getElementById("useTokenBtn").onclick = () => {
        const token = document.getElementById("displayToken").value;
        hideResetTokenOverlay();
        showResetConfirmOverlay(token);
      };
      document.getElementById("resetConfirmForm").onsubmit = handleResetConfirm;
      document.getElementById("cancelResetConfirmBtn").onclick = hideResetConfirmOverlay;

      // Events view
      document.getElementById("addEventTrigger").onclick = showEventSheet;
      document.getElementById("cancelEventBtn").onclick = hideEventSheet;
      document.getElementById("eventForm").onsubmit = handleEventSubmit;

      // Event detail nav
      document.getElementById("backToEventsBtn").onclick = () => {
        showEventsView();
        renderEvents();
      };

      // Event notes
      document.getElementById("showEventNotesBtn").onclick = showEventNotesOverlay;
      document.getElementById("cancelEventCommentsBtn").onclick = hideEventNotesOverlay;
      document.getElementById("eventNotesForm").onsubmit = handleEventNotesSubmit;

      // Event edit overlay
      document.getElementById("editEventBtn").onclick = showEventEditSheet;
      document.getElementById("cancelEventEditBtn").onclick = hideEventEditSheet;
      document.getElementById("eventEditForm").onsubmit = handleEventEditSubmit;

      // Rounds view
      document.getElementById("addRoundTrigger").onclick = openRoundForCreate;
      document.getElementById("exportRoundsBtn").onclick = exportRoundsToText;
      document.getElementById("cancelRoundBtn").onclick = hideRoundSheet;
      document.getElementById("roundForm").onsubmit = handleRoundSubmit;
      document.getElementById("roundNumber").oninput = updateSheetRoundLabel;

      // Round details overlay
      document.getElementById("closeRoundDetailBtn").onclick = hideRoundDetails;
      document.getElementById("saveRoundCommentsBtn").onclick = saveRoundComments;

      // Check if already logged in
      checkCurrentUser();
    });
  </script>
</body>
</html>
